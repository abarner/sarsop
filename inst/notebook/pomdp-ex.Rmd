Comparison of Milad matrices

```{r}
library("appl")
source("milad.R")
knitr::opts_chunk$set(cache = TRUE)

```

```{r}
gdist = "ricker"
Num_s = 50
Num_a = 50
Num_z = 50
sigma_g = 0.2
sigma_m = 0.2
r = 1
K = 33
C = 10
noise_dist = "lognormal"
discount = 0.95

# Creates transition matrix
T = create_T(Num_s,Num_a,sigma_g,gdist,r,C,K,noise_dist)
# creates emission matrix
O = create_O(Num_s,Num_a,Num_z,sigma_m,noise_dist)
# creates reward function
R = create_R(Num_s,Num_a)
#R = create_R2(Num_s,Num_a,0.1)
```


```{r}
system.time( out0 <- pomdp(T,O, R, discount, mc.cores = parallel::detectCores(), precision = 1, memory = 1500) )
```

```{r}
h <- out0[[2]]
x <- seq_along(h)
plot(x, x - h)
```






## Compare to exact:

```{r}
states <- 0:50
actions <- states
f <- function(x, h, r = 1, K = 33){
  s <- pmax(x - h, 0)
  s * exp(r * (1 - s / K) )
}
sigma_g <- 0.2
reward_fn <- function(x,h) pmin(x,h)
discount <- 0.95
```

## Semi-analytic solution

```{r}
fun <- function(x) -f(x,0) + x / discount
out <- optimize(f = fun, interval = c(min(states),max(states)))
S_star <- round(out$minimum)
exact_policy <- sapply(states, function(x) if(x < S_star) 0 else x - S_star)
```


```{r}
h <- out0[[2]]
x <- seq_along(h)
plot(x, x - h)

points(states, states - exact_policy, col = 'red', pch = 3)
```

